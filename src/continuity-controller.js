const fs = require('fs').promises;
const path = require('path');

class ContinuityController {
    constructor(cacheDir, fetcher, options = {}) {
        this.cacheDir = cacheDir;
        this.fetcher = fetcher;
        this.options = options;
        
        this.hlsPlaylist = path.join(cacheDir, 'stream.m3u8'); // Single source of truth
        this.currentPosition = 0;
        this.isGenerating = false;
        this.lastUpdate = null;
        
        this.segmentDuration = options.segmentDuration || 2; // seconds
    }

    async initialize() {
        console.log('üéÆ Initializing Continuity Controller...');
        
        // Load current position from checkpoint
        const stats = this.fetcher.getStats();
        this.currentPosition = stats.currentSegment;
        
        console.log(`üìç Starting playback from segment ${this.currentPosition}`);
        return true;
    }

    async generatePlaylist() {
        if (this.isGenerating) {
            return this.hlsPlaylist;
        }
        
        this.isGenerating = true;
        
        try {
            // Use the HLS playlist directly generated by StreamFetcher
            this.hlsPlaylist = path.join(this.cacheDir, 'stream.m3u8');
            
            // Check if HLS playlist exists
            try {
                await fs.access(this.hlsPlaylist);
                console.log(`üìù Using HLS playlist: ${this.hlsPlaylist}`);
                this.lastUpdate = new Date();
                return this.hlsPlaylist;
            } catch (error) {
                console.log('‚ö†Ô∏è  HLS playlist not yet available');
                return null;
            }
            
        } catch (error) {
            console.error('‚ùå Failed to access HLS playlist:', error.message);
            return null;
        } finally {
            this.isGenerating = false;
        }
    }

    async updatePlaylist() {
        // Update playlist every 10 seconds or when needed
        const needsUpdate = !this.lastUpdate || 
                           (Date.now() - this.lastUpdate.getTime()) > 10000;
        
        if (needsUpdate) {
            return await this.generatePlaylist();
        }
        
        return this.hlsPlaylist || path.join(this.cacheDir, 'stream.m3u8');
    }

    async seekTo(segmentId) {
        console.log(`‚è≠Ô∏è  Seeking to segment ${segmentId}`);
        
        const availableSegments = this.fetcher.getAvailableSegments();
        
        if (!availableSegments.includes(segmentId)) {
            // Segment not available, find nearest available
            const nearest = availableSegments
                .sort((a, b) => Math.abs(a - segmentId) - Math.abs(b - segmentId))[0];
            
            if (nearest !== undefined) {
                console.log(`‚ö†Ô∏è  Segment ${segmentId} not available, using nearest: ${nearest}`);
                segmentId = nearest;
            } else {
                console.log('‚ùå No segments available for seeking');
                return false;
            }
        }
        
        this.currentPosition = segmentId;
        await this.generatePlaylist();
        
        console.log(`‚úÖ Seeked to segment ${segmentId}`);
        return true;
    }

    async advancePosition(segmentsCount = 1) {
        const newPosition = this.currentPosition + segmentsCount;
        const availableSegments = this.fetcher.getAvailableSegments();
        
        // Check if new position is available
        if (availableSegments.includes(newPosition)) {
            this.currentPosition = newPosition;
            console.log(`‚è≠Ô∏è  Advanced to segment ${this.currentPosition}`);
            await this.generatePlaylist();
            return true;
        } else {
            console.log(`‚ö†Ô∏è  Cannot advance to segment ${newPosition} - not available yet`);
            return false;
        }
    }

    async handleStreamFailure() {
        console.log('üÜò Handling stream failure - attempting continuity...');
        
        const stats = this.fetcher.getStats();
        
        // Try to resume from last known good position
        const availableSegments = this.fetcher.getAvailableSegments();
        let resumePosition = this.currentPosition;
        
        // Find next available segment
        while (!availableSegments.includes(resumePosition) && resumePosition < stats.lastSegment) {
            resumePosition++;
        }
        
        if (availableSegments.includes(resumePosition)) {
            console.log(`üîÑ Resuming from segment ${resumePosition}`);
            await this.seekTo(resumePosition);
            return true;
        } else {
            // No segments available, wait for fetcher to catch up
            console.log('‚è∞ Waiting for segments to be available...');
            return false;
        }
    }

    async waitForSegments(count = 5, timeout = 30000) {
        console.log(`‚è≥ Waiting for ${count} segments to be available...`);
        
        const startTime = Date.now();
        
        while (Date.now() - startTime < timeout) {
            const availableSegments = this.fetcher.getAvailableSegments();
            const availableFromPosition = availableSegments
                .filter(id => id >= this.currentPosition).length;
            
            if (availableFromPosition >= count) {
                console.log(`‚úÖ ${availableFromPosition} segments available`);
                return true;
            }
            
            // Wait 1 second before checking again
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        console.log(`‚è∞ Timeout waiting for segments`);
        return false;
    }

    getPlaylistPath() {
        return this.hlsPlaylist || path.join(this.cacheDir, 'stream.m3u8');
    }

    getCurrentPosition() {
        return this.currentPosition;
    }

    getStatus() {
        const stats = this.fetcher.getStats();
        const availableSegments = this.fetcher.getAvailableSegments();
        const lookaheadSegments = availableSegments.filter(id => id >= this.currentPosition).length;
        
        return {
            currentPosition: this.currentPosition,
            availableSegments: availableSegments.length,
            lookaheadSegments: lookaheadSegments,
            lookaheadSeconds: lookaheadSegments * this.segmentDuration,
            lastUpdate: this.lastUpdate,
            isGenerating: this.isGenerating,
            playlistExists: this.hlsPlaylist
        };
    }
}

module.exports = ContinuityController;